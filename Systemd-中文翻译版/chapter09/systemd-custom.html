<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="application/xhtml+xml; charset=utf-8" />
    <title>
      9.10.&nbsp;Systemd 使用和配置
    </title>
    <link rel="stylesheet" type="text/css" href="../stylesheets/lfs.css" />
    <meta name="generator" content="DocBook XSL Stylesheets V1.79.1" />
    <link rel="stylesheet" href="../stylesheets/lfs-print.css" type=
    "text/css" media="print" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  </head>
  <body class="lfs" id="lfs-20200927-systemd，中文翻译版">
    <div class="navheader">
      <h4>
        Linux From Scratch - 版本 20200927-systemd，中文翻译版
      </h4>
      <h3>
        第&nbsp;9&nbsp;章&nbsp;系统配置
      </h3>
      <ul>
        <li class="prev">
          <a accesskey="p" href="etcshells.html" title=
          "创建 /etc/shells 文件">上一页</a>
          <p>
            创建 /etc/shells 文件
          </p>
        </li>
        <li class="next">
          <a accesskey="n" href="../chapter10/chapter10.html" title=
          "使 LFS 系统可引导">下一页</a>
          <p>
            使 LFS 系统可引导
          </p>
        </li>
        <li class="up">
          <a accesskey="u" href="chapter09.html" title=
          "第&nbsp;9&nbsp;章&nbsp;系统配置">上一级</a>
        </li>
        <li class="home">
          <a accesskey="h" href="../index.html" title=
          "Linux From Scratch - 版本 20200927-systemd，中文翻译版">起始页</a>
        </li>
      </ul>
    </div>
    <div class="sect1" lang="zh-cn" xml:lang="zh-cn">
      <h1 class="sect1">
        <a id="ch-config-systemd-custom" name=
        "ch-config-systemd-custom"></a>9.10. Systemd 使用和配置
      </h1>
      <div class="sect2" lang="zh-cn" xml:lang="zh-cn">
        <h2 class="sect2">
          9.10.1. 基础设置
        </h2>
        <p>
          <code class="filename">/etc/systemd/system.conf</code> 文件包含一组控制
          systemd 基本功能的选项。默认文件中所有条目都被注释掉，并标明了默认值。可以在这里修改日志级别，以及其他一些基本日志设定。参阅
          <code class="filename">systemd-system.conf(5)</code> man
          手册页面了解每个选项的详细信息。
        </p>
      </div>
      <div class="sect2" lang="zh-cn" xml:lang="zh-cn">
        <h2 class="sect2">
          9.10.2. 禁用引导时自动清屏
        </h2>
        <p>
          Systemd 的默认行为是在引导过程结束时清除屏幕。如果希望的话，您可以运行以下命令，修改这一行为：
        </p>
        <pre class="userinput"><kbd class=
        "command">mkdir -pv /etc/systemd/system/getty@tty1.service.d

cat &gt; /etc/systemd/system/getty@tty1.service.d/noclear.conf &lt;&lt; EOF
<code class="literal">[Service]
TTYVTDisallocate=no</code>
EOF</kbd></pre>
        <p>
          您总是可以用 root 身份运行 <strong class="userinput"><code>journalctl
          -b</code></strong> 命令，查阅引导消息。
        </p>
      </div>
      <div class="sect2" lang="zh-cn" xml:lang="zh-cn">
        <h2 class="sect2">
          9.10.3. 禁止将 tmpfs 挂载到 /tmp
        </h2>
        <p>
          默认情况下，<code class="filename">/tmp</code> 将被挂载 tmpfs
          文件系统。如果不希望这样，可以执行以下命令覆盖这一行为：
        </p>
        <pre class="userinput"><kbd class=
        "command">ln -sfv /dev/null /etc/systemd/system/tmp.mount</kbd></pre>
        <p>
          或者，如果希望使用一个单独的 <code class="filename">/tmp</code> 分区，在 <code class=
          "filename">/etc/fstab</code> 中为其添加一个条目。
        </p>
        <div class="admon warning">
          <img alt="[警告]" src="../images/warning.png" />
          <h3>
            警告
          </h3>
          <p>
            如果使用了单独的 <code class="filename">/tmp</code>
            分区，不要创建上面的符号链接。这会导致根文件系统 (/) 无法重新挂载为可读写，使得系统在引导后不可用。
          </p>
        </div>
      </div>
      <div class="sect2" lang="zh-cn" xml:lang="zh-cn">
        <h2 class="sect2">
          9.10.4. 配置文件自动创建和删除
        </h2>
        <p>
          有一些创建或删除文件、目录的服务：
        </p>
        <div class="itemizedlist">
          <ul>
            <li class="listitem">
              <p>
                systemd-tmpfiles-clean.service
              </p>
            </li>
            <li class="listitem">
              <p>
                systemd-tmpfiles-setup-dev.service
              </p>
            </li>
            <li class="listitem">
              <p>
                systemd-tmpfiles-setup.service
              </p>
            </li>
          </ul>
        </div>
        <p>
          它们的系统配置文件位于 <code class=
          "filename">/usr/lib/tmpfiles.d/*.conf</code>。本地配置文件位于 <code class=
          "filename">/etc/tmpfiles.d</code>。<code class=
          "filename">/etc/tmpfiles.d</code> 中的文件覆盖 <code class=
          "filename">/usr/lib/tmpfiles.d</code> 中的同名文件。参阅 <code class=
          "filename">tmpfiles.d(5)</code> man 手册页面，了解配置文件格式的细节。
        </p>
        <p>
          注意 <code class="filename">/usr/lib/tmpfiles.d/*.conf</code>
          文件的语法较难理解。例如，删除 /tmp 目录下文件的默认规则是文件 <code class=
          "filename">/usr/lib/tmpfiles.d/tmp.conf</code> 的一行：
        </p>
        <pre class="screen">q /tmp 1777 root root 10d</pre>
        <p>
          类别字段 q 表示创建一个带有配额的子卷，它实际上只适用于 btrfs 文件系统。它引用类别 v，类别 v 又引用类别 d
          (目录)。对于类别 d，会在目录不存在时自动创建它，并根据配置文件调整其权限和所有者。如果 age
          参数被指定，该目录中较老的文件会被自动清理。
        </p>
        <p>
          如果默认参数不符合您的期望，您可以将文件复制到 <code class=
          "filename">/etc/tmpfiles.d</code> 目录，再编辑复制得到的副本。例如：
        </p>
        <pre class="userinput"><kbd class="command">mkdir -p /etc/tmpfiles.d
cp /usr/lib/tmpfiles.d/tmp.conf /etc/tmpfiles.d</kbd></pre>
      </div>
      <div class="sect2" lang="zh-cn" xml:lang="zh-cn">
        <h2 class="sect2">
          9.10.5. 覆盖系统服务默认行为
        </h2>
        <p>
          Systemd 单元的参数可以通过在 <code class=
          "filename">/etc/systemd/system</code> 中创建一个包含配置文件的目录而覆盖。例如：
        </p>
        <pre class="userinput"><kbd class=
        "command">mkdir -pv /etc/systemd/system/foobar.service.d

cat &gt; /etc/systemd/system/foobar.service.d/foobar.conf &lt;&lt; EOF
<code class="literal">[Service]
Restart=always
RestartSec=30</code>
EOF</kbd></pre>
        <p>
          参阅 <code class="filename">systemd.unit(5)</code> man
          手册页面获取更多信息。在创建配置文件后，执行 <strong class="userinput"><code>systemctl
          daemon-reload</code></strong> 和 <strong class=
          "userinput"><code>systemctl restart
          foobar</code></strong>，激活对服务进行的修改。
        </p>
      </div>
      <div class="sect2" lang="zh-cn" xml:lang="zh-cn">
        <h2 class="sect2">
          9.10.6. 调试引导过程
        </h2>
        <p>
          与 SysVinit 或 BSD 风格 init 系统不同，systemd 使用统一格式处理不同种类的引导文件 (或称为单元)。命令
          <span class="command"><strong>systemctl</strong></span>
          能够启用、禁用单元文件，或控制、查询单元文件的状态。以下是一些常用的命令：
        </p>
        <div class="itemizedlist">
          <ul>
            <li class="listitem">
              <p>
                <span class="command"><strong>systemctl list-units -t
                <em class="replaceable"><code>&lt;service&gt;</code></em>
                [--all]</strong></span>: 列出已加载的服务 (service) 类型单元文件。
              </p>
            </li>
            <li class="listitem">
              <p>
                <span class="command"><strong>systemctl list-units -t
                <em class="replaceable"><code>&lt;target&gt;</code></em>
                [--all]</strong></span>: 列出已加载的引导目标 (target) 类型单元文件。
              </p>
            </li>
            <li class="listitem">
              <p>
                <span class="command"><strong>systemctl show -p Wants
                <em class=
                "replaceable"><code>&lt;multi-user.target&gt;</code></em></strong></span>:
                显示所有依赖于 multi-user 引导目标的单元，引导目标 (target)是一种和 SysVinit 中运行级别
                (runlevel) 地位相同的特殊单元文件。
              </p>
            </li>
            <li class="listitem">
              <p>
                <span class="command"><strong>systemctl status <em class=
                "replaceable"><code>&lt;servicename.service&gt;</code></em></strong></span>:
                显示名为 servicename 的服务的状态。如果没有同名的其他类型单元文件，可以省略 .service
                后缀。其他类型的单元文件有 .socket 文件 (它创建一个监听套接字，提供和 inetd/xinetd 类似的功能)。
              </p>
            </li>
          </ul>
        </div>
      </div>
      <div class="sect2" lang="zh-cn" xml:lang="zh-cn">
        <h2 class="sect2">
          9.10.7. 使用 systemd 日志
        </h2>
        <p>
          (默认情况下) 在使用 systemd 引导的系统上，systemd-journald 服务负责处理日志，它取代了传统的 Unix
          syslog 守护进程。如果您希望的话，也可以添加一个普通 syslog 守护进程，它和 systemd-journald
          可以一起工作。systemd-journald 程序将日志项储存为二进制格式，而不是纯文本日志文件。为了解析日志文件，需要使用
          systemd 提供的 <span class=
          "command"><strong>journalctl</strong></span> 命令。下面是该命令的常见用法：
        </p>
        <div class="itemizedlist">
          <ul>
            <li class="listitem">
              <p>
                <span class="command"><strong>journalctl
                -r</strong></span>：按时间顺序，倒序显示所有日志内容。
              </p>
            </li>
            <li class="listitem">
              <p>
                <span class="command"><strong>journalctl -u <em class=
                "replaceable"><code>UNIT</code></em></strong></span>:
                显示与给定单元文件 UNIT 关联的日志。
              </p>
            </li>
            <li class="listitem">
              <p>
                <span class="command"><strong>journalctl -b[=ID]
                -r</strong></span>: 按时间倒序，显示自上次引导以来 (或编号为 ID 的引导中) 的所有日志。
              </p>
            </li>
            <li class="listitem">
              <p>
                <span class="command"><strong>journalctl -f</strong></span>:
                提供类似 tail -f 的功能 (不断将新日志项输出到屏幕)。
              </p>
            </li>
          </ul>
        </div>
      </div>
      <div class="sect2" lang="zh-cn" xml:lang="zh-cn">
        <h2 class="sect2">
          9.10.8. 处理核心转储
        </h2>
        <p>
          核心转储在调试崩溃的程序时非常有用，特别是对于守护进程崩溃的情况。在 systemd 引导的系统上，核心转储由
          <span class="command"><strong>systemd-coredump</strong></span>
          处理。它会在日志中记录核心转储，并且将核心转储文件本身存储到 <code class=
          "filename">/var/lib/systemd/coredump</code> 中。如果要获取和处理核心转储文件，可以使用
          <span class="command"><strong>coredumpctl</strong></span>
          工具。下面给出它的常用命令的示例：
        </p>
        <div class="itemizedlist">
          <ul>
            <li class="listitem">
              <p>
                <span class="command"><strong>coredumpctl
                -r</strong></span>：按时间顺序，倒序显示所有核心转储记录。
              </p>
            </li>
            <li class="listitem">
              <p>
                <span class="command"><strong>coredumpctl -1
                info</strong></span>：显示最近一次核心转储的信息。
              </p>
            </li>
            <li class="listitem">
              <p>
                <span class="command"><strong>coredumpctl -1
                debug</strong></span>：将最后一次核心转储加载到 <a class="ulink" href=
                "http://www.linuxfromscratch.org/blfs/view/svn/general/gdb.html">
                GDB</a> 中。
              </p>
            </li>
          </ul>
        </div>
        <p>
          核心转储可能使用大量磁盘空间。为了限制核心转储使用的最大磁盘空间，可以在 <code class=
          "filename">/etc/systemd/coredump.conf.d</code> 中创建一个配置文件。例如：
        </p>
        <pre class="userinput"><kbd class=
        "command">mkdir -pv /etc/systemd/coredump.conf.d

cat &gt; /etc/systemd/coredump.conf.d/maxuse.conf &lt;&lt; EOF
<code class="literal">[Coredump]
MaxUse=5G</code>
EOF</kbd></pre>
        <p>
          参阅 man 手册页面 <code class=
          "filename">systemd-coredump(8)</code>，<code class=
          "filename">coredumpctl(1)</code>，以及 <code class=
          "filename">coredump.conf.d(5)</code> 了解更多信息。
        </p>
      </div>
      <div class="sect2" lang="zh-cn" xml:lang="zh-cn">
        <h2 class="sect2">
          9.10.9. 持续运行进程
        </h2>
        <p>
          从 systemd 的 230 版本开始，在用户会话结束时，所有用户进程都被杀死，即使使用了 nohup 或 <code class=
          "function">daemon()</code> 、<code class="function">setsid</code>
          等函数也不例外。这是开发者有意做出的修改，将传统的宽松环境改为更加严格的环境。如果您需要让持续运行的程序 (例如
          <span class="command"><strong>screen</strong></span> 或 <span class=
          "command"><strong>tmux</strong></span>)
          在用户会话结束后保持运行，这项新的行为会导致问题。有三种方法使得这类驻留进程在用户会话结束后继续运行：
        </p>
        <div class="itemizedlist">
          <ul>
            <li class="listitem">
              <p>
                <span class=
                "emphasis"><em>仅为选定的用户启用进程驻留</em></span>：普通用户有执行命令
                <span class="command"><strong>loginctl
                enable-linger</strong></span> 启用进程驻留的权限，管理员可以使用带 <em class=
                "parameter"><code>user</code></em>
                参数的该命令，为特定用户启用进程驻留。在启用进程驻留后，可以使用 <span class=
                "command"><strong>systemd-run</strong></span>
                命令启动持续运行的进程。例如，<span class="command"><strong>systemd-run
                --scope --user
                /usr/bin/screen</strong></span>。如果您为您的用户启用了进程驻留，则
                user@.service
                将持续运行，甚至在所有登录会话关闭后仍然运行，而且会在系统引导时自动启动。这种方法的好处是可以显式地允许或禁止进程在用户会话结束后继续运行，但却破坏了和
                <span class="command"><strong>nohup</strong></span> 等工具，和使用
                <code class="function">daemon()</code> 函数的工具的兼容性。
              </p>
            </li>
            <li class="listitem">
              <p>
                <span class=
                "emphasis"><em>为整个系统启用进程驻留</em></span>：您可以在将<em class=
                "parameter"><code>KillUserProcesses=no</code></em> 设置行加入
                <code class=
                "filename">/etc/systemd/logind.conf</code>，为所有用户全局地启用进程驻留。它的好处是允许所有用户继续使用旧方法，但无法进行明确控制。
              </p>
            </li>
            <li class="listitem">
              <p>
                <span class="emphasis"><em>在编译时禁用该功能</em></span>：您可以在构建
                systemd 时传递参数 <em class=
                "parameter"><code>-Ddefault-kill-user-process=no</code></em>
                给 <span class="command"><strong>meson</strong></span>，使得
                systemd 默认启用进程驻留。这完全禁用了 systemd 在会话结束时杀死用户进程的功能。
              </p>
            </li>
          </ul>
        </div>
      </div>
    </div>
    <div class="navfooter">
      <ul>
        <li class="prev">
          <a accesskey="p" href="etcshells.html" title=
          "创建 /etc/shells 文件">上一页</a>
          <p>
            创建 /etc/shells 文件
          </p>
        </li>
        <li class="next">
          <a accesskey="n" href="../chapter10/chapter10.html" title=
          "使 LFS 系统可引导">下一页</a>
          <p>
            使 LFS 系统可引导
          </p>
        </li>
        <li class="up">
          <a accesskey="u" href="chapter09.html" title=
          "第&nbsp;9&nbsp;章&nbsp;系统配置">上一级</a>
        </li>
        <li class="home">
          <a accesskey="h" href="../index.html" title=
          "Linux From Scratch - 版本 20200927-systemd，中文翻译版">起始页</a>
        </li>
      </ul>
    </div>
  </body>
</html>
